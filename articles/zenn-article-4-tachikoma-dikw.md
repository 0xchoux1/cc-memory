---
title: "cc-memory 設計編: タチコマ並列化とDIKW知恵昇華の構想"
emoji: "🤖"
type: "tech"
topics: ["claude", "mcp", "ai", "typescript", "memory"]
published: false
---

## TL;DR

- **タチコマ並列化**と**DIKW知恵昇華**を設計・実装した
- 本記事は**設計思想と実装の解説**
- 実運用での検証結果は次回記事で報告予定

https://github.com/0xchoux1/cc-memory

---

## この記事の位置づけ

本記事は「設計編」です。

- **今回**: なぜこう設計したか、どう実装したか
- **次回（予定）**: 実際に使ってみてどうだったか

「作ってみたけど使わなかった」という結果もありえます。その場合は正直に報告します。

---

## 背景: 解決したい課題

[前々回の記事](https://zenn.dev/tshpaper/articles/b849add53f7226)で、AIの自律性向上に必要な4つの要素を挙げました。

```
┌─────────────────────────────────────────────────────────────┐
│ AIエージェントの自律性向上（L0→L4）                         │
├─────────────────────────────────────────────────────────────┤
│ LLMの4つの欠落:                                             │
│ 1. 階層型メモリシステム ← cc-memory 基本機能                │
│ 2. 外部トリガー＋目標管理                                   │
│ 3. 常駐プロセス＋イベントストリーム                         │
│ 4. アクションコストモデル                                   │
└─────────────────────────────────────────────────────────────┘
```

cc-memory は「階層型メモリシステム」を提供していますが、運用していて2つの課題が見えてきました：

### 課題1: 知識の孤立

複数のClaudeインスタンス（開発環境、テスト環境など）が別々に学習しても、その知識は共有されない。

**本当に問題か？**: 正直なところ、複数環境でClaude Codeを同時運用するユースケースがどれだけあるか分からない。ただ、将来的にマルチエージェント構成が一般的になった場合に備えて、仕組みだけは用意しておきたい。

### 課題2: 経験の未活用

個別の経験（エピソード記憶）が蓄積されても、そこから普遍的な原則を抽出する仕組みがない。

**本当に問題か？**: これは実感している。同じような問題に何度も遭遇するが、毎回「前にも似たことがあった気がする」で終わる。パターン化・原則化できれば、より効率的になるはず。

---

## 設計1: タチコマ並列化

### インスピレーション: 攻殻機動隊のタチコマ

攻殻機動隊に登場するAI搭載戦車「タチコマ」は、毎晩「並列化」を行います。各機体がその日に得た経験を共有し、全機体で同じ記憶を持つようになります。

この「並列化」をファイルベースで実現しました。

```
┌─────────────────┐     export     ┌─────────────────┐
│   Tachikoma A   │ ────────────▶  │   memory.json   │
│  (開発環境)      │                │   (共有ファイル)  │
└─────────────────┘                └────────┬────────┘
                                            │ import
                                            ▼
                                   ┌─────────────────┐
                                   │   Tachikoma B   │
                                   │  (テスト環境)    │
                                   └─────────────────┘
```

### API設計

```typescript
// 各インスタンスを初期化
tachikoma_init({
  id: "tachi-dev",
  name: "Development Tachikoma"
});

// 記憶をエクスポート
const exported = tachikoma_export({
  since_timestamp: lastSyncTime  // 差分のみエクスポート可能
});

// 別インスタンスでインポート
tachikoma_import({
  data: exported,
  strategy: "merge_learnings",  // 競合時の解決戦略
  auto_resolve: true
});
```

### 競合解決戦略

同じ記憶が両方のインスタンスで変更された場合の解決戦略：

| 戦略 | 説明 |
|------|------|
| `newer_wins` | 新しい方を採用 |
| `merge_learnings` | 学習内容をマージ（エピソード記憶向け） |
| `merge_observations` | 観察をマージ（意味記憶向け） |
| `higher_importance` | 重要度が高い方を採用 |
| `higher_confidence` | 信頼度が高い方を採用 |
| `manual` | 手動で解決 |

### 検証したいこと

- 実際に複数環境で運用する場面があるか
- 競合解決が発生するケースはどれくらいあるか
- ファイルベースの同期で十分か、リアルタイム同期が必要か

---

## 設計2: DIKW知恵昇華

### DIKWモデルとは

DIKWは知識管理の階層モデルです：

- **D**ata: 生データ
- **I**nformation: 文脈を持ったデータ
- **K**nowledge: 活用可能な知識
- **W**isdom: 普遍的な原則・判断基準

これを記憶の昇華プロセスとして実装しました：

```
Level 1: Raw Experience（エピソード記憶）
    │
    │  観察・分析
    ▼
Level 2: Pattern（パターン）
    │  「大量APIレスポンスでUIが固まる」
    │
    │  複数パターンの統合
    ▼
Level 3: Insight（洞察）
    │  「フロントエンド・バックエンド両方が無制限データ取得で被害を受ける」
    │
    │  普遍化・原則化
    ▼
Level 4: Wisdom（知恵）
    「すべてのコレクションAPIは、デフォルトでページネーションと制限を持つべき」
```

### API設計（仮想的な使用例）

以下は「こう使う想定」という設計時の仮想例です。実際にこの流れで知恵が蓄積されるかは検証が必要です。

```typescript
// 1. パターンを記録（Level 2）
pattern_create({
  pattern: "大量のAPIレスポンスがUIをブロックする",
  supporting_episodes: ["ep-123"],
  confidence: 0.8,
  related_tags: ["API", "performance", "frontend"]
});

// 2. 洞察を生成（Level 3）
insight_create({
  insight: "フロントエンドとバックエンドの両方が無制限データ取得で問題を起こす",
  reasoning: "異なるドメインで同様のパターンが観察された",
  source_patterns: ["pattern-123", "pattern-456"],
  domains: ["API", "Performance"],
  confidence: 0.9
});

// 3. 知恵に昇華（Level 4）
wisdom_create({
  name: "APIデフォルト制限の原則",
  principle: "すべてのコレクション取得APIは、デフォルトでページネーション、フィルタリング、フィールド選択をサポートし、無制限取得を禁止すべきである",
  description: "大量データ取得はフロントエンドのUI固まりとバックエンドのリソース枯渇の両方を引き起こす",
  derived_from_insights: ["insight-789"],
  applicable_domains: ["API設計", "REST", "GraphQL"],
  limitations: ["内部専用APIでは適用不要な場合がある"]
});
```

### 知恵の活用と検証

知恵は使うたびにフィードバックを記録し、信頼度が更新される設計：

```typescript
// 知恵を適用した結果を記録
wisdom_apply({
  wisdom_id: "wisdom-123",
  context: "新規ユーザー一覧APIの設計",
  result: "success",
  feedback: "ページネーションを実装し、パフォーマンス問題を未然に防止"
});
```

### 検証したいこと

- **手動運用は現実的か**: `pattern_create`、`insight_create`、`wisdom_create` を手動で呼ぶ運用が継続できるか
- **自動化は必要か**: 手動が面倒なら、エピソードからパターンを自動抽出する機能が必要
- **知恵まで到達するか**: 実際の運用で Level 4 まで昇華する機会があるか

---

## 設計3: マルチエージェント協調

複数の専門エージェントが協調する場合に備えて、「誰が何を学んだか」を追跡する仕組み：

```typescript
agent_register({
  name: "Frontend Specialist",
  role: "frontend",
  specializations: ["React", "TypeScript", "CSS"],
  knowledge_domains: ["Web開発", "UX"]
});
```

### 検証したいこと

- Claude Code の Task ツール（サブエージェント）との連携で使う場面があるか
- エージェントごとの知識分離が有用なケースがあるか

---

## 実装状況

### テスト結果

- **TachikomaParallelization.test.ts**: 15テスト ✅
- **WisdomDIKW.test.ts**: 20テスト ✅
- **動作テストスクリプト**: 10テスト ✅

全138テストがパス。**機能としては動く**状態。

### インストール方法

```bash
cd cc-memory
git pull
npm install
npm run build
```

---

## 次のステップ: フィールドテスト

これらの機能を実際に運用し、以下を検証します：

| 検証項目 | 観点 |
|---------|------|
| タチコマ並列化 | 複数環境での運用ニーズは実際にあるか |
| DIKW手動運用 | パターン/洞察/知恵を手動で記録し続けられるか |
| 自動化の必要性 | 手動が面倒なら自動抽出機能を優先実装 |
| 知恵の蓄積 | 実際に「知恵」レベルまで到達するケースがあるか |

結果は次回記事で報告します。「作ったけど使わなかった」という結果も含めて正直に。

---

## リンク

- **リポジトリ**: https://github.com/0xchoux1/cc-memory
- **前回記事**: [cc-memory v1.1: Server Instructionsで「CLAUDE.md設定不要」を実現](...)
- **最初の記事**: [「持続的記憶」を実装する ― cc-memory の設計と実装](...)
- **背景記事**: [AIを動かすのは簡単、自分で動くAIは難しい](https://zenn.dev/tshpaper/articles/b849add53f7226)
